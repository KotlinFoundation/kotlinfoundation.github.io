{"data":{"allMdx":{"nodes":[{"id":"0526d5ad-70e4-511e-9a5c-b2c6b8960866","excerpt":"The Kotlin Foundation is launching the Kotlin Ecosystem Mentorship program. Many developers want to contribute to Kotlin-related open-source projects but don‚Äôt know where to start or feel intimidated about contributing. At the same time, maintainers are overwhelmed. This program is designed to fix that.\n\nHow it works:\n\nWe pair an experienced Kotlin open-source maintainer (mentor) with someone making their first meaningful contribution (mentee). Mentors guide mentees through the full journey: setting up the project, understanding the workflow, choosing a reasonable first task, reviewing changes, and giving feedback until the contribution is merged.\n\nWhat counts as a contribution?\n\nIt‚Äôs not restricted to just code. Documentation, tooling, examples, tutorials, and other project improvements are welcome ‚Äì as long as the mentor considers the contribution meaningful.\n\nPilot details:\n\n‚Ä¢ Timeline: February 16 ‚Äì April 16 ‚Ä¢ Mentors: ~30‚Äì60 minutes/week ‚Ä¢ Mentees: ~2‚Äì4 hours/week (depending on the task) ‚Ä¢ Pilot size: ~10 mentor-mentee pairs\n\nPerks:\n\nEvery pair that successfully merges a meaningful contribution will receive some Kotlin swag. One randomly selected finishing pair will win a trip to KotlinConf 2026 in Munich.\n\nIf you maintain a Kotlin-related open-source project and want to mentor a new contributor, we‚Äôd love to have you join.\n\nApply to mentor Apply as a mentee Program rules More details","fields":{"slug":"/news/join-mentorship-program/"},"frontmatter":{"date":"February 02, 2026","title":"Join the Kotlin Ecosystem Mentorship Program","spoilerSize":305}},{"id":"5b35c284-55ef-51b7-af7a-4c09653b7b08","excerpt":"For Victoria Alajemba, a Software Engineer from Nigeria studying in Paris, GSoC was a bridge between learning and impact. Working on the IntelliJ Platform Gradle Plugin, she integrated Gradle‚Äôs Problems API and Reporting API, creating richer, standardized reports and exploring parallel verification for faster builds. Guided by Jakub Chrzanowski from JetBrains, she strengthened key workflows used by thousands of plugin developers. Project page\n\nMentor: Jakub Chrzanowski (JetBrains)\n\nAbout the author\n\nI am Victoria Chuks Alajemba, a software engineer passionate about developer tooling from Nigeria. I‚Äôve been building mobile applications professionally since 2021, after learning programming via YouTube in 2020, and I am currently exploring the world of plugins and extensions across several platforms like the IntelliJ Platform, VS Code, Chrome, and more. I love developer tools and programming in general, but more than that, I love the idea of being able to create something that solves a problem. I currently study artificial intelligence and data science for businesses at aivancity School of AI & Data for Business & Technology in Paris.\n\nIntro and motivation\nWhy this project matters\n\nThe IntelliJ Platform Gradle Plugin is a critical tool for developers building plugins that target the IntelliJ Platform. It is used by JetBrains and third-party developers to build, test, verify, and publish their plugins. Improvements to this tool will ensure that the thousands of developers who rely on it have a great experience.\n\nThe problem it solves\n\nThe verifyPlugin task, a Gradle task that is part of the IntelliJ Platform Gradle Plugin, enables developers to check that their plugin works against various IntelliJ-based IDEs (PyCharm, Android Studio, IntelliJ IDEA Community Edition, and more). However, the IntelliJ Platform Gradle Plugin team had identified certain areas for enhancement:\n\nNon-standard reporting: The verifyPlugin task used its own custom reporting system rather than Gradle's Reporting API, making reports less configurable and harder to integrate with standard Gradle workflows. Limited error context: Build issues that were reported could benefit from a more detailed and structured process with the Problems API. Unclear performance characteristics: We needed to investigate whether parallel execution could speed up verification against multiple IDE versions.\nTechnical highlights\nCore technical achievements\nGradle Problems API integration ‚úÖ Merged PR #1987\nReplaced ad-hoc error reporting in VerifyPluginTask with Gradle's structured Problems API. Enhanced error reporting with contextual details, file locations, suggested solutions, and documentation links.\nGradle Reporting API integration ‚úÖ Merged PR #2016\nImplemented VerifyPluginConfigurationReportsImpl with ReportContainer<SingleFileReport> for standardized reporting. Added TXT report support with configurable output locations via the Gradle DSL. Integrated the Reporting<VerifyPluginConfigurationReports> interface for task-level report configuration. Demonstrated successful Reporting API usage in simpler validation contexts.\nGradle Reporting API for VerifyPluginTask üîÑ Draft PR #1996\nImplemented ReportingContainer supporting HTML, Markdown, and plain text reports. Exposed configuration through IntelliJPlatformExtension for user customization. Blocked by IntelliJ Plugin Verifier's single output directory limitation.\nParallel verification research üîç Closed PR #1948\nPrototyped a Gradle Worker API for concurrent verifyPlugin execution against multiple IDE versions. Discovered IntelliJ Plugin Verifier already uses internal ExecutorService concurrency. Identified the true bottleneck: sequential IDE dependency downloads (not verification). Researched dependency substitution, a ResolutionResult API, and parallel resolution strategies.\nGradle Cookbook documentation ‚úÖ Merged PR #58\nAuthored a practical guide on wiring the Reporting API into plugin tasks. Provided configuration examples and best practices for plugin developers.\nFeatures, architecture, and key gains\nKey features\nStructured problem reporting: Consistent issue visualization across IDEs, consoles, and BuildScans. Configurable reports: DSL-based report format and location customization. Rich error context: File locations, documentation links, and suggested solutions. Gradle ecosystem alignment: Leverages Problems API (Gradle 8.6+) and Reporting API standards.\nArchitecture\nProblems API architecture\nProblems.kt: Centralized registry of ProblemIds organized by:\nProblemGroups Groups.VerifyPlugin for verification-specific issues. Dynamic VerificationFailure factory generating ProblemIds from FailureLevel enum.\n/**\n * Contains problem IDs to be used when reporting a problem with the Problems API\n * for the IntelliJ Platform Gradle Plugin.\n *\n * @see org.gradle.api.problems.ProblemId\n * @see org.gradle.api.problems.Problems\n */\n@Suppress(\"UnstableApiUsage\")\ninternal object Problems {\n\n    /**\n     * Contains [ProblemGroup]s to be used with the Problems API for the IntelliJ Platform Gradle Plugin.\n     */\n    private object Groups {\n        val IntelliJPlatformPlugin = ProblemGroup.create(\n            \"intellij-platform-plugin-group\",\n            \"IntelliJ Platform Plugin Problems\"\n        )\n\n        val VerifyPlugin = ProblemGroup.create(\"$ID.verify-plugin\", \"Verify Plugin\")\n    }\n\n    object VerifyPlugin {\n        val InvalidPlugin = ProblemId.create(\n            \"invalid-plugin\",\n            \"Invalid Plugin\",\n            Groups.VerifyPlugin,\n        )\n        // ....\n    }\n}\n\nreportError() helper: Wraps exceptions with Problems API metadata, including clickable report URLs.\n/**\n * Helper function to report an error using the Problems API.\n *\n * @param exception The exception to report. It is suppressed to allow a wrapper exception be thrown with an updated message.\n * @param problemId The ID of the problem to report.\n * @param problemsReportUrl Optional URL used to include the report file's path to the exception's message.\n * Expected value: [org.gradle.api.file.ProjectLayout.getBuildDirectory]/reports/problems/problems-report.html\n * @param spec An action that further configures the problem specification.\n * @return A RuntimeException that includes the original exception and the problem details.\n */\ninternal fun ProblemReporter.reportError(\n    exception: Exception,\n    problemId: ProblemId,\n    problemsReportUrl: String?,\n    spec: Action<ProblemSpec>\n): RuntimeException {\n\n    val message = buildString {\n        append(exception.message)\n        if (problemsReportUrl != null) {\n            append(\"${System.lineSeparator()}[Incubating] See full report here: $problemsReportUrl\")\n        }\n    }\n\n    return throwing(RuntimeException(message).also { it.addSuppressed(exception) }, problemId) {\n        spec.execute(this)\n\n        withException(exception)\n        severity(Severity.ERROR)\n    }\n}\n\nOutput parsing pipeline: collectProblems() ‚Üí parseItemsToMap() ‚Üí structured ProblemSpec generation. Severity mapping: FailureLevel enum values map to Severity.ERROR/WARNING based on configuration.\n\nSample in BuildScan:\n\nIn-IDE sample:\n\nReporting API architecture\nVerifyPluginConfigurationReportsImpl: DelegatingReportContainer delegating to DefaultReportContainer.\nopen class VerifyPluginConfigurationReportsImpl @Inject constructor(\n    owner: Describable,\n    objectFactory: ObjectFactory,\n) : DelegatingReportContainer<SingleFileReport>(\n    DefaultReportContainer.create(\n        objectFactory,\n        SingleFileReport::class.java\n    ) { factory ->\n        val list: Collection<SingleFileReport> = ImmutableList.of(\n            factory.instantiateReport(DefaultSingleFileReport::class.java, \"txt\", owner)\n        )\n\n        list\n    }\n\n), VerifyPluginConfigurationReports {\n\n    override val txt: SingleFileReport\n        get() = getByName(\"txt\")\n}\n\nReport lifecycle: Task execution ‚Üí validation results ‚Üí SingleFileReport generation ‚Üí configurable output. DSL integration\n// Task DSL configuration\nreports {\n    txt.required.set(true)\n    txt.outputLocation.convention(\n        project.layout.buildDirectory.file(\"reports/verifyPluginConfiguration/report.txt\")\n    )\n}\n\nDependency injection: @Inject ObjectFactory for report instance creation.\n@CacheableTask\nabstract class VerifyPluginProjectConfigurationTask : DefaultTask(), IntelliJPlatformVersionAware, KotlinMetadataAware,\n    RuntimeAware, PluginAware, ModuleAware, Reporting<VerifyPluginConfigurationReports> {\n\n    /**\n     * Service for creating custom Gradle types\n     */\n    @get:Inject\n    abstract val objectFactory: ObjectFactory\n\n    ‚Ä¶\n    /**\n     * Container for results generated from verifying the plugin's project configuration.\n     *\n     * Output location is configured using [org.gradle.api.reporting.internal.DefaultSingleFileReport.getOutputLocation].\n     * Default value: [org.gradle.api.file.ProjectLayout.getBuildDirectory]/reports/verifyPluginConfiguration/report.txt\n     */\n    private val reports: VerifyPluginConfigurationReports = objectFactory.newInstance(\n        VerifyPluginConfigurationReportsImpl::class.java,\n        Describables.quoted(\"Task\", identityPath)\n    )\n\n    private val txtReportFile get() = if (reports.txt.required.get()) reports.txt.outputLocation else null\n\n    ...\n}\n\nKey gains\nDeveloper experience: Rich, actionable error messages replace verbose exceptions. Maintainability: Centralized problem definitions and standardized reporting. Performance insights: Identified dependency resolution as the primary bottleneck. Gradle compliance: Aligns IPGP with modern Gradle APIs and best practices.\nProject repository and demos\n\nMain repository\n\nMid-term progress demo\n\nAbout my GSoC experience\nHow I discovered GSoC\n\nI've been using Kotlin since I started‚Ä¶","fields":{"slug":"/news/gsoc-2025-intellij-gradle-plugin/"},"frontmatter":{"date":"November 19, 2025","title":"Google Summer of Code 2025 ‚Äì IntelliJ Platform Gradle Plugin ‚Äì Gradle Reporting and Parallel Verifications","spoilerSize":null}}]}}}