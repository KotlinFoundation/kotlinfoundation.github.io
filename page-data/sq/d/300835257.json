{"data":{"allMdx":{"nodes":[{"id":"5b35c284-55ef-51b7-af7a-4c09653b7b08","excerpt":"For Victoria Alajemba, a Software Engineer from Nigeria studying in Paris, GSoC was a bridge between learning and impact. Working on the IntelliJ Platform Gradle Plugin, she integrated Gradle‚Äôs Problems API and Reporting API, creating richer, standardized reports and exploring parallel verification for faster builds. Guided by Jakub Chrzanowski from JetBrains, she strengthened key workflows used by thousands of plugin developers. Project page\n\nMentor: Jakub Chrzanowski (JetBrains)\n\nAbout the author\n\nI am Victoria Chuks Alajemba, a software engineer passionate about developer tooling from Nigeria. I‚Äôve been building mobile applications professionally since 2021, after learning programming via YouTube in 2020, and I am currently exploring the world of plugins and extensions across several platforms like the IntelliJ Platform, VS Code, Chrome, and more. I love developer tools and programming in general, but more than that, I love the idea of being able to create something that solves a problem. I currently study artificial intelligence and data science for businesses at aivancity School of AI & Data for Business & Technology in Paris.\n\nIntro and motivation\nWhy this project matters\n\nThe IntelliJ Platform Gradle Plugin is a critical tool for developers building plugins that target the IntelliJ Platform. It is used by JetBrains and third-party developers to build, test, verify, and publish their plugins. Improvements to this tool will ensure that the thousands of developers who rely on it have a great experience.\n\nThe problem it solves\n\nThe verifyPlugin task, a Gradle task that is part of the IntelliJ Platform Gradle Plugin, enables developers to check that their plugin works against various IntelliJ-based IDEs (PyCharm, Android Studio, IntelliJ IDEA Community Edition, and more). However, the IntelliJ Platform Gradle Plugin team had identified certain areas for enhancement:\n\nNon-standard reporting: The verifyPlugin task used its own custom reporting system rather than Gradle's Reporting API, making reports less configurable and harder to integrate with standard Gradle workflows. Limited error context: Build issues that were reported could benefit from a more detailed and structured process with the Problems API. Unclear performance characteristics: We needed to investigate whether parallel execution could speed up verification against multiple IDE versions.\nTechnical highlights\nCore technical achievements\nGradle Problems API integration ‚úÖ Merged PR #1987\nReplaced ad-hoc error reporting in VerifyPluginTask with Gradle's structured Problems API. Enhanced error reporting with contextual details, file locations, suggested solutions, and documentation links.\nGradle Reporting API integration ‚úÖ Merged PR #2016\nImplemented VerifyPluginConfigurationReportsImpl with ReportContainer<SingleFileReport> for standardized reporting. Added TXT report support with configurable output locations via the Gradle DSL. Integrated the Reporting<VerifyPluginConfigurationReports> interface for task-level report configuration. Demonstrated successful Reporting API usage in simpler validation contexts.\nGradle Reporting API for VerifyPluginTask üîÑ Draft PR #1996\nImplemented ReportingContainer supporting HTML, Markdown, and plain text reports. Exposed configuration through IntelliJPlatformExtension for user customization. Blocked by IntelliJ Plugin Verifier's single output directory limitation.\nParallel verification research üîç Closed PR #1948\nPrototyped a Gradle Worker API for concurrent verifyPlugin execution against multiple IDE versions. Discovered IntelliJ Plugin Verifier already uses internal ExecutorService concurrency. Identified the true bottleneck: sequential IDE dependency downloads (not verification). Researched dependency substitution, a ResolutionResult API, and parallel resolution strategies.\nGradle Cookbook documentation ‚úÖ Merged PR #58\nAuthored a practical guide on wiring the Reporting API into plugin tasks. Provided configuration examples and best practices for plugin developers.\nFeatures, architecture, and key gains\nKey features\nStructured problem reporting: Consistent issue visualization across IDEs, consoles, and BuildScans. Configurable reports: DSL-based report format and location customization. Rich error context: File locations, documentation links, and suggested solutions. Gradle ecosystem alignment: Leverages Problems API (Gradle 8.6+) and Reporting API standards.\nArchitecture\nProblems API architecture\nProblems.kt: Centralized registry of ProblemIds organized by:\nProblemGroups Groups.VerifyPlugin for verification-specific issues. Dynamic VerificationFailure factory generating ProblemIds from FailureLevel enum.\n/**\n * Contains problem IDs to be used when reporting a problem with the Problems API\n * for the IntelliJ Platform Gradle Plugin.\n *\n * @see org.gradle.api.problems.ProblemId\n * @see org.gradle.api.problems.Problems\n */\n@Suppress(\"UnstableApiUsage\")\ninternal object Problems {\n\n    /**\n     * Contains [ProblemGroup]s to be used with the Problems API for the IntelliJ Platform Gradle Plugin.\n     */\n    private object Groups {\n        val IntelliJPlatformPlugin = ProblemGroup.create(\n            \"intellij-platform-plugin-group\",\n            \"IntelliJ Platform Plugin Problems\"\n        )\n\n        val VerifyPlugin = ProblemGroup.create(\"$ID.verify-plugin\", \"Verify Plugin\")\n    }\n\n    object VerifyPlugin {\n        val InvalidPlugin = ProblemId.create(\n            \"invalid-plugin\",\n            \"Invalid Plugin\",\n            Groups.VerifyPlugin,\n        )\n        // ....\n    }\n}\n\nreportError() helper: Wraps exceptions with Problems API metadata, including clickable report URLs.\n/**\n * Helper function to report an error using the Problems API.\n *\n * @param exception The exception to report. It is suppressed to allow a wrapper exception be thrown with an updated message.\n * @param problemId The ID of the problem to report.\n * @param problemsReportUrl Optional URL used to include the report file's path to the exception's message.\n * Expected value: [org.gradle.api.file.ProjectLayout.getBuildDirectory]/reports/problems/problems-report.html\n * @param spec An action that further configures the problem specification.\n * @return A RuntimeException that includes the original exception and the problem details.\n */\ninternal fun ProblemReporter.reportError(\n    exception: Exception,\n    problemId: ProblemId,\n    problemsReportUrl: String?,\n    spec: Action<ProblemSpec>\n): RuntimeException {\n\n    val message = buildString {\n        append(exception.message)\n        if (problemsReportUrl != null) {\n            append(\"${System.lineSeparator()}[Incubating] See full report here: $problemsReportUrl\")\n        }\n    }\n\n    return throwing(RuntimeException(message).also { it.addSuppressed(exception) }, problemId) {\n        spec.execute(this)\n\n        withException(exception)\n        severity(Severity.ERROR)\n    }\n}\n\nOutput parsing pipeline: collectProblems() ‚Üí parseItemsToMap() ‚Üí structured ProblemSpec generation. Severity mapping: FailureLevel enum values map to Severity.ERROR/WARNING based on configuration.\n\nSample in BuildScan:\n\nIn-IDE sample:\n\nReporting API architecture\nVerifyPluginConfigurationReportsImpl: DelegatingReportContainer delegating to DefaultReportContainer.\nopen class VerifyPluginConfigurationReportsImpl @Inject constructor(\n    owner: Describable,\n    objectFactory: ObjectFactory,\n) : DelegatingReportContainer<SingleFileReport>(\n    DefaultReportContainer.create(\n        objectFactory,\n        SingleFileReport::class.java\n    ) { factory ->\n        val list: Collection<SingleFileReport> = ImmutableList.of(\n            factory.instantiateReport(DefaultSingleFileReport::class.java, \"txt\", owner)\n        )\n\n        list\n    }\n\n), VerifyPluginConfigurationReports {\n\n    override val txt: SingleFileReport\n        get() = getByName(\"txt\")\n}\n\nReport lifecycle: Task execution ‚Üí validation results ‚Üí SingleFileReport generation ‚Üí configurable output. DSL integration\n// Task DSL configuration\nreports {\n    txt.required.set(true)\n    txt.outputLocation.convention(\n        project.layout.buildDirectory.file(\"reports/verifyPluginConfiguration/report.txt\")\n    )\n}\n\nDependency injection: @Inject ObjectFactory for report instance creation.\n@CacheableTask\nabstract class VerifyPluginProjectConfigurationTask : DefaultTask(), IntelliJPlatformVersionAware, KotlinMetadataAware,\n    RuntimeAware, PluginAware, ModuleAware, Reporting<VerifyPluginConfigurationReports> {\n\n    /**\n     * Service for creating custom Gradle types\n     */\n    @get:Inject\n    abstract val objectFactory: ObjectFactory\n\n    ‚Ä¶\n    /**\n     * Container for results generated from verifying the plugin's project configuration.\n     *\n     * Output location is configured using [org.gradle.api.reporting.internal.DefaultSingleFileReport.getOutputLocation].\n     * Default value: [org.gradle.api.file.ProjectLayout.getBuildDirectory]/reports/verifyPluginConfiguration/report.txt\n     */\n    private val reports: VerifyPluginConfigurationReports = objectFactory.newInstance(\n        VerifyPluginConfigurationReportsImpl::class.java,\n        Describables.quoted(\"Task\", identityPath)\n    )\n\n    private val txtReportFile get() = if (reports.txt.required.get()) reports.txt.outputLocation else null\n\n    ...\n}\n\nKey gains\nDeveloper experience: Rich, actionable error messages replace verbose exceptions. Maintainability: Centralized problem definitions and standardized reporting. Performance insights: Identified dependency resolution as the primary bottleneck. Gradle compliance: Aligns IPGP with modern Gradle APIs and best practices.\nProject repository and demos\n\nMain repository\n\nMid-term progress demo\n\nAbout my GSoC experience\nHow I discovered GSoC\n\nI've been using Kotlin since I started‚Ä¶","fields":{"slug":"/news/gsoc-2025-intellij-gradle-plugin/"},"frontmatter":{"date":"November 19, 2025","title":"Google Summer of Code 2025 ‚Äì IntelliJ Platform Gradle Plugin ‚Äì Gradle Reporting and Parallel Verifications","spoilerSize":null}},{"id":"a61900a4-b11e-580c-980d-c7847157ca3e","excerpt":"Based in New York City, Android Engineer Vanessa Johnson spent her summer improving how Kotlin developers experience code quality. Her project integrated the Gradle Problems API into popular tools like Detekt and Ktlint, unifying error reporting across consoles, IDEs, and HTML reports for cleaner, more actionable feedback. Project page\n\nMentors: Don√°t Csik√≥s and Reinhold Degenfellner (both from Gradle)\n\nAbout the autor\n\nHey everyone, my name is Vanessa Johnson, and I am an Android Engineer based in New York City. I‚Äôve been at my company for a little over a year now and was excited about the opportunity to take part in Google Summer of Code (GSoC) 2025. My proposal was Enhanced Kotlin Code Quality Reporting with Gradle Problem API: Integration with Detekt and Ktlint.\n\nMotivation\n\nAs developers, we always favor tools that enhance and streamline the programming process, including plugins that provide error reporting and insights to improve code quality. Kotlin developers using Gradle rely on tools like Detekt and Ktlint to enforce code quality. This project aimed to implement a unified and actionable code quality reporting system through the integration of the recently introduced Gradle Problems API. As an engineer who uses tools like Detekt and Ktlint daily, I wanted the opportunity to contribute to these popular tools to enhance their usefulness. This past summer I was also exploring how to make a linter or a plugin, so this project also gave me more insight into that.\n\nGSoC experience\n\nI discovered GSoC a couple years ago when my previous mentor mentioned it when I was looking for summer internships and did not have any luck elsewhere. Unfortunately the deadline to apply to be a contributor had passed at that time, but I kept it in my back pocket to apply for in the future.\n\nSince I am a full-time Android Engineer, I wanted to contribute to the Kotlin Foundation, as that is the language we use to develop our Android app. I wrote the proposal and met with the potential mentors to talk more about implementation and my goals for the project. To my surprise, my proposal was accepted!\n\nNow, of course, I encountered challenges along the way. Learning about plugins took extra time, having a full-time job when we were coming out with big and new feature releases that I was leading did not help, and a small but noticeable one was the time difference between me and my mentors. The last one wasn‚Äôt too bad, but when things started to pile up at work or when I had to prepare for my conference talks, it did take my focus away from this project.\n\nSome takeaways are that I learned more about how plugins work, learned about open source, and connected with people that I would normally not have the chance to. I am still interested in open-source projects, but not necessarily plugin development. Nonetheless I enjoyed participating in the project and have a couple PRs that I need to fix up before they can be merged. You can find the project page here, which also has the linked PRs. Collaboration, communication, and more Kotlin, of course, were skills I practiced during this project, which I am grateful for since they all contribute to becoming a better and more well-rounded engineer.\n\nParticipating was a rewarding experience, and it opened up my eyes to the open-source community. To anyone considering GSoC, especially beginners, I would say to apply! It is very beginner-friendly, and you can acquire valuable skills that you would not easily gain elsewhere. Below are some links where you can find me and my work! Thanks for reading about my GSoC journey.\n\nResources and contacts\n\nYou can see what other things I am working on or have done thus far on my website, where you can also find links to my most recent talks if you are interested! I also have a newsletter that I try to stay consistent with, which is about mobile application development and any projects or conferences I have in flight. You can also find me on LinkedIn!","fields":{"slug":"/news/gsoc-2025-kotlin-quality-reporting/"},"frontmatter":{"date":"November 19, 2025","title":"Google Summer of Code 2025 ‚Äì Enhanced Kotlin Code Quality Reporting with Gradle Problem API: Integration with Detekt and Ktlint","spoilerSize":null}}]}}}